using System;
using System.Collections.Generic;
using System.Text;
using CodeLibrary;
using System.Linq;

namespace ProjectEuler
{
    /// <summary>
    /// Highly divisible triangular number
    /// </summary>
    /// <remarks>
    /// The sequence of triangle numbers is generated by adding the natural numbers.
    /// So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. 
    /// The first ten terms would be:
    /// 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
    /// Let us list the factors of the first seven triangle numbers:
    /// 1: 1
    /// 3: 1,3
    /// 6: 1,2,3,6
    /// 10: 1,2,5,10
    /// 15: 1,3,5,15
    /// 21: 1,3,7,21
    /// 28: 1,2,4,7,14,28
    /// We can see that 28 is the first triangle number to have over five divisors.
    /// What is the value of the first triangle number to have over five hundred divisors?
    /// Answer:
    /// 76576500
    /// </remarks>


    public class Problem12 : IPEProblem
    {
        public string Answer => _getOutput();

        private int _divisorLimit = 0;
        private int _number = 0;
        private int _previous = 0;        
                
        public Problem12()
        { }

        public Problem12(int limit)
        {            
            ShowAnswer(limit);
        }

        private string _getOutput()
        {
            int result = FindTriangleNumberByDivisors(_divisorLimit);
            return $"triangle number: {result}";
        }

        public void ShowAnswer(object problemSize)
        {
            "*Problem 12*".ToConsole();
            _divisorLimit = (int)problemSize;
            Answer.ToConsole();
        }

        public IEnumerable<int> TriangleNumbers(int limit = 0)
        {
            int count = 0;
            while (true)            
            {                
                _number += 1;
                int triangle = _number + _previous;
                yield return triangle;                
                _previous = triangle;
                count++;
                if (limit > 0 && count == limit) yield break;
            }
        }
        
        public static int GetFactorCount(int number)
        {
            return number.GetFactors().AddRange(new HashSet<int> { 1, number }).Count;
        }

        public static void ShowFactors(int[] numbers)
        {
            foreach (var number in numbers)
            {
                var factors = number.GetFactors().AddRange(new HashSet<int> { 1, number });
                $"{number}: ".Print(); factors.ToConsole();
            }
        }

        public static int FindTriangleNumberByDivisors(int divisorLimit)
        {
            var p = new Problem12();
            foreach(int number in p.TriangleNumbers())
            {
                int factors = GetFactorCount(number);
                if (factors >= divisorLimit)
                {
                    $"{number} => has {factors} divisors".ToConsole();
                    return number;
                }                
            }
            return -1;
        }
    }
}
